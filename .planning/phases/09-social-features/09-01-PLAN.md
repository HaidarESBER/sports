---
phase: 09-social-features
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [prisma/schema.prisma, src/app/api/programs/[id]/like/route.ts, src/app/api/programs/[id]/comments/route.ts, src/app/api/sessions/[id]/like/route.ts, src/app/api/sessions/[id]/comments/route.ts, src/app/api/comments/[id]/route.ts, src/app/api/feed/route.ts]
autonomous: true
---

<objective>
Create backend API for social features: likes, comments, and activity feed.

Purpose: Enable social interactions (likes, comments) on programs and sessions, and provide an activity feed showing what followed users are doing.
Output: Database schema updates + API endpoints for likes, comments, and activity feed
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@prisma/schema.prisma
@src/app/api/users/[id]/follow/route.ts
@src/app/api/discover/programs/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update Prisma schema with social models</name>
  <files>prisma/schema.prisma</files>
  <action>
Add three new models to the Prisma schema:

1. Like model:
```prisma
model Like {
  id          String   @id @default(cuid())
  userId      String
  programId   String?
  sessionId   String?
  createdAt   DateTime @default(now())

  user    User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  program Program? @relation(fields: [programId], references: [id], onDelete: Cascade)
  session Session? @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@unique([userId, programId])
  @@unique([userId, sessionId])
}
```

2. Comment model:
```prisma
model Comment {
  id          String   @id @default(cuid())
  content     String
  userId      String
  programId   String?
  sessionId   String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  user    User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  program Program? @relation(fields: [programId], references: [id], onDelete: Cascade)
  session Session? @relation(fields: [sessionId], references: [id], onDelete: Cascade)
}
```

3. Activity model for feed:
```prisma
model Activity {
  id          String   @id @default(cuid())
  type        String   // "like_program", "like_session", "comment_program", "comment_session", "create_program", "create_session", "follow"
  userId      String
  programId   String?
  sessionId   String?
  targetUserId String? // for follow activity
  createdAt   DateTime @default(now())

  user       User     @relation("UserActivities", fields: [userId], references: [id], onDelete: Cascade)
  program    Program? @relation(fields: [programId], references: [id], onDelete: Cascade)
  session    Session? @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  targetUser User?    @relation("TargetUserActivities", fields: [targetUserId], references: [id], onDelete: Cascade)
}
```

Add relations to existing models:
- User: add `likes Like[]`, `comments Comment[]`, `activities Activity[] @relation("UserActivities")`, `targetActivities Activity[] @relation("TargetUserActivities")`
- Program: add `likes Like[]`, `comments Comment[]`, `activities Activity[]`
- Session: add `likes Like[]`, `comments Comment[]`, `activities Activity[]`

After schema update, run: npx prisma generate && npx prisma db push
  </action>
  <verify>npx prisma validate succeeds, npx prisma generate succeeds</verify>
  <done>Schema includes Like, Comment, Activity models with proper relations</done>
</task>

<task type="auto">
  <name>Task 2: Create program like endpoint</name>
  <files>src/app/api/programs/[id]/like/route.ts</files>
  <action>
Create POST and DELETE endpoints for liking/unliking a program.

POST /api/programs/[id]/like:
- Requires authentication
- Check program exists and is public (or user is owner)
- Check not already liked (unique constraint)
- Create Like record
- Create Activity record (type: "like_program")
- Return: { success: true, isLiked: true, likesCount }

DELETE /api/programs/[id]/like:
- Requires authentication
- Find and delete the like
- Delete corresponding activity (optional, can leave for history)
- Return: { success: true, isLiked: false, likesCount }

GET /api/programs/[id]/like:
- No auth required
- Return: { isLiked: boolean (if auth), likesCount: number }

Follow same patterns as /api/users/[id]/follow/route.ts
  </action>
  <verify>curl with POST creates like, DELETE removes it, GET returns status</verify>
  <done>Program like endpoint supports POST/DELETE/GET with activity tracking</done>
</task>

<task type="auto">
  <name>Task 3: Create session like endpoint</name>
  <files>src/app/api/sessions/[id]/like/route.ts</files>
  <action>
Create POST, DELETE, GET endpoints for liking/unliking a session.

Same pattern as program like:
- POST creates like + activity
- DELETE removes like
- GET returns like status and count

Check session author is public before allowing like (consistent with discovery).
  </action>
  <verify>Session like endpoints work correctly</verify>
  <done>Session like endpoint supports POST/DELETE/GET with activity tracking</done>
</task>

<task type="auto">
  <name>Task 4: Create program comments endpoint</name>
  <files>src/app/api/programs/[id]/comments/route.ts</files>
  <action>
Create GET and POST endpoints for program comments.

GET /api/programs/[id]/comments:
- No auth required (public programs have public comments)
- Check program is public or user is owner
- Return paginated comments: { comments: [...], total, page, totalPages }
- Each comment includes: id, content, createdAt, user: { id, name, image }
- Order by createdAt desc (newest first)

POST /api/programs/[id]/comments:
- Requires authentication
- Check program is public or user is owner
- Validate content (required, max 1000 chars)
- Create Comment record
- Create Activity record (type: "comment_program")
- Return created comment with user info
  </action>
  <verify>GET returns comments, POST creates new comment</verify>
  <done>Program comments endpoint supports GET (paginated) and POST with activity tracking</done>
</task>

<task type="auto">
  <name>Task 5: Create session comments endpoint</name>
  <files>src/app/api/sessions/[id]/comments/route.ts</files>
  <action>
Create GET and POST endpoints for session comments.

Same pattern as program comments:
- GET returns paginated comments
- POST creates comment + activity
- Check session author is public before allowing access
  </action>
  <verify>Session comments endpoints work correctly</verify>
  <done>Session comments endpoint supports GET and POST with activity tracking</done>
</task>

<task type="auto">
  <name>Task 6: Create comment management endpoint</name>
  <files>src/app/api/comments/[id]/route.ts</files>
  <action>
Create endpoints for managing individual comments.

DELETE /api/comments/[id]:
- Requires authentication
- User must be comment owner (or owner of the program/session being commented on)
- Delete the comment
- Return: { success: true }

PATCH /api/comments/[id]:
- Requires authentication
- User must be comment owner only
- Update content (validate max 1000 chars)
- Return updated comment
  </action>
  <verify>Comment owner can delete and edit their comments</verify>
  <done>Comment management endpoint supports DELETE and PATCH</done>
</task>

<task type="auto">
  <name>Task 7: Create activity feed endpoint</name>
  <files>src/app/api/feed/route.ts</files>
  <action>
Create GET endpoint for the activity feed.

GET /api/feed:
- Requires authentication
- Returns activities from users the current user follows
- Activity types: like_program, like_session, comment_program, comment_session, create_program, create_session, follow
- Include related data based on type:
  - user: { id, name, image }
  - program: { id, name, sport } if applicable
  - session: { id, name, sport } if applicable
  - targetUser: { id, name, image } for follow activities
- Pagination: page, limit (default 20, max 100)
- Order by createdAt desc
- Return: { activities, total, page, totalPages }

Query logic:
1. Get list of user IDs the current user follows
2. Fetch activities where userId is in that list
3. Filter to only public content:
   - Programs with isPublic=true
   - Sessions where author isPublic=true
  </action>
  <verify>Feed returns activities from followed users with correct data</verify>
  <done>Activity feed endpoint returns paginated activities from followed users</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] npx prisma validate succeeds
- [ ] npm run build succeeds
- [ ] Like endpoints (program/session) return correct status
- [ ] Comment endpoints support CRUD operations
- [ ] Feed endpoint returns activities from followed users
- [ ] Activities are created when users like/comment
- [ ] All endpoints handle auth correctly
</verification>

<success_criteria>
- All tasks completed
- Database schema includes Like, Comment, Activity models
- Social API endpoints fully functional
- Activity tracking works for all social actions
</success_criteria>

<output>
After completion, create `.planning/phases/09-social-features/09-01-SUMMARY.md`
</output>
